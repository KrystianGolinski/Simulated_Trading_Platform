# C++ Trading Engine Technical Documentation

## 1. Introduction

This document provides a technical overview of the C++ Trading Engine, a high-performance backtesting system.

### 1.1. Core Design Principles

-   **Performance**: Built with modern C++17 for high-speed, memory-efficient processing of large datasets.
-   **Modularity**: A service-oriented architecture with dependency injection allows components to be developed and tested in isolation.
-   **Safety**: The `Result<T>` pattern is used for error handling in performance-critical paths, avoiding the overhead of exceptions.
-   **Temporal Accuracy**: A key design feature is the dynamic mitigation of survivorship bias, ensuring backtests are historically accurate.
-   **Extensibility**: The Strategy pattern allows new trading algorithms to be added with minimal friction.

### 1.2. Key Components and Directory Mapping

-   `src/main.cpp`: Application entry point.
-   `src/trading_engine.cpp`: The central orchestrator for all simulations.
-   `src/command_dispatcher.cpp`: Routes command-line arguments.
-   `include/trading_strategy.h`: Abstract base class for all trading strategies.
-   `src/portfolio.cpp`: Manages cash and stock positions.
-   `src/market_data.cpp`: Handles data retrieval from the database.
-   `include/result.h`: Defines the `Result<T>` type for error handling.
-   `CMakeLists.txt`: The build configuration file.

## 2. Architecture

### 2.1. High-Level Data Flow

1.  **Input**: The engine receives a request via command-line arguments, often including a path to a JSON configuration file.
2.  **Dispatch**: `CommandDispatcher` parses the input and routes it to the appropriate function in `TradingEngine`.
3.  **Data Retrieval**: `MarketData` service fetches historical price data from the TimescaleDB database.
4.  **Simulation Loop**: `TradingEngine` iterates through the historical data, day by day.
5.  **Temporal Validation**: On each day, the engine checks if the stocks in the simulation are actively trading, dynamically handling IPOs and delistings.
6.  **Signal Generation**: The selected `TradingStrategy` (e.g., `MovingAverageCrossoverStrategy`) analyzes the data and generates BUY, SELL, or HOLD signals.
7.  **Execution**: `ExecutionService` processes these signals, creating orders that are fulfilled by the `Portfolio`.
8.  **Output**: After the simulation, results (performance metrics, trades) are serialized to JSON and printed to standard output.

### 2.2. Survivorship Bias Mitigation

The engine does not simply filter out delisted stocks at the start. Instead, it performs **dynamic temporal validation** on every day of a simulation:

-   It uses the `is_stock_tradeable()` database function to check if a stock was listed and not delisted on the current simulation date.
-   A stock is only included in strategy calculations for the days it was actively trading.
-   If a stock held in the portfolio is delisted, the engine automatically force-sells the position to simulate the real-world event.

## 3. Reference

### 3.1. Core Data Structures

-   **`SimulationConfig`**: Holds the complete configuration for a backtest, loaded from JSON.
-   **`PriceData`**: Represents a single OHLCV data point for a stock on a given day.
-   **`TradingSignal`**: Represents a BUY, SELL, or HOLD signal generated by a strategy.
-   **`BacktestResult`**: A comprehensive structure containing all performance metrics and trade logs from a completed simulation.

### 3.2. Key Classes and Responsibilities

-   **`TradingEngine`**: The main service that orchestrates the entire backtest.
-   **`CommandDispatcher`**: Parses command-line arguments and dispatches commands.
-   **`ArgumentParser`**: Handles the logic of parsing arguments and JSON files.
-   **`TradingStrategy`**: The interface for all trading algorithms.
-   **`Portfolio`**: Manages the simulation's cash and stock holdings.
-   **`Position`**: Represents a holding of a single stock.
-   **`MarketData`**: An abstraction layer over the database connection for fetching price data.
-   **`DatabaseConnection`**: Manages the low-level connection to PostgreSQL.
-   **`ExecutionService`**: Translates signals into portfolio actions.
-   **`ProgressService`**: Reports the progress of long-running simulations.

### 3.3. Error Handling

The engine uses a combination of the `Result<T>` pattern and a custom exception hierarchy.
-   **`Result<T>`**: Used for functions that can fail in a predictable way (e.g., a database query returning no rows). This avoids exception overhead in tight loops.
-   **`TradingException`**: A hierarchy of custom exceptions (`DatabaseException`, `StrategyException`, etc.) is used for unrecoverable or system-level errors.

### 3.4. Command-Line Interface

-   `--simulate`: Runs a simulation with parameters provided on the command line.
-   `--backtest`: Runs a simulation using a JSON configuration file.
-   `--test-db`: Tests the connection to the database.
-   `--status`: Checks the engine's status.

**Example JSON Configuration:**
```json
{
    "symbols": ["AAPL", "GOOGL"],
    "start_date": "2023-01-01",
    "end_date": "2023-12-31",
    "capital": 100000.0,
    "strategy": "ma_crossover",
    "strategy_parameters": {
        "short_period": 10,
        "long_period": 20
    }
}
```

### 3.5. Build Process

The engine is built using CMake.

1.  **Install Dependencies**: `sudo apt-get install build-essential cmake libpq-dev nlohmann-json3-dev`
2.  **Configure**: `cmake -B build`
3.  **Compile**: `cmake --build build -j$(nproc)`
4.  **Run Tests**: `cd build && ctest`